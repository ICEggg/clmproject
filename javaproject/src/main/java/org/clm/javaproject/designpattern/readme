1.单例模式：
工作中用Mgr01就够了，静态内部类也蛮好的，Mgr04是最完美的写法

2.策略模式：
java中的Comparator用的就是策略模式
比如一个int类型数组，排序，实现一个sort方法，参数就是这个数组，
但是，如果要排序一个double，float，或者按一个对象的属性排序，比如，猫的weight，height时，就要重新添加一个sort方法
策略模式，在排序的时候，传入对应的数组，传入要比较的策略（按照weight，还是height来排序），不改变原来的代码，
增加一个类，实现对应的接口，可扩展性就变得很好

3.工厂模式：
比如要一个车或者飞机的对象，在对应的类里都有一个run方法，通常就是new一个，然后调用new方法。
或者写一个接口，有个run方法，车、飞机都实现这个接口。这样如果要扩展交通工具，实现这个接口就行了。
但是：现在要任意定制交通工具的制作工程，实现接口这个方式就有局限性了。
这里就引入：简单工厂模式，SimpleVehicleFactory


抽象工厂方法：一个抽象工厂类，具体的工厂继承这个抽象类，具体的实现类，继承这个具体的工厂类

形容词用接口，名词用抽象类


